<%#
 Copyright 2013-2025 the original author or authors from the JHipster project.

 This file is part of the JHipster project, see https://www.jhipster.tech/
 for more information.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

      https://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
-%>
package <%= packageName %>.service.embedding;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

<%_ for (const vectorEntity of vectorEntitiesSaathratri) { _%>
import <%= packageName %>.domain.<%= vectorEntity.entityClass %>;
import <%= packageName %>.repository.<%= vectorEntity.entityClass %>Repository;
<%_ } _%>

import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Application runner that automatically populates missing vector embeddings on startup.
 * Similar to Liquibase - only processes records that need embeddings, skips if already done.
 *
 * This runner:
 * 1. Checks each entity for records with NULL embeddings but non-NULL source fields
 * 2. Generates embeddings only for those records
 * 3. Skips entirely if all embeddings are already populated
 *
 * Enable/disable via application property:
 *   embedding.startup-migration.enabled=true (default: true)
 *
 * @see EmbeddingService
 * @see EmbeddingMigrationService
 */
@Component
@Order(100) // Run after Liquibase (which typically runs at order 0-10)
@ConditionalOnProperty(name = "embedding.startup-migration.enabled", havingValue = "true", matchIfMissing = true)
public class EmbeddingStartupMigrationRunner implements ApplicationRunner {

    private static final Logger LOG = LoggerFactory.getLogger(EmbeddingStartupMigrationRunner.class);

    private static final long RATE_LIMIT_DELAY_MS = 100; // Delay between API calls to respect rate limits

    private final EmbeddingService embeddingService;
<%_ for (const vectorEntity of vectorEntitiesSaathratri) { _%>
    private final <%= vectorEntity.entityClass %>Repository <%= vectorEntity.entityInstance %>Repository;
<%_ } _%>

    public EmbeddingStartupMigrationRunner(
        EmbeddingService embeddingService<% for (const vectorEntity of vectorEntitiesSaathratri) { %>,
        <%= vectorEntity.entityClass %>Repository <%= vectorEntity.entityInstance %>Repository<% } %>
    ) {
        this.embeddingService = embeddingService;
<%_ for (const vectorEntity of vectorEntitiesSaathratri) { _%>
        this.<%= vectorEntity.entityInstance %>Repository = <%= vectorEntity.entityInstance %>Repository;
<%_ } _%>
    }

    @Override
    @Transactional
    public void run(ApplicationArguments args) {
        if (!embeddingService.isAvailable()) {
            LOG.info("Embedding service not available (OPENAI_API_KEY not configured). Skipping startup embedding migration.");
            return;
        }

        LOG.info("Starting embedding migration check...");

        int totalMigrated = 0;
<%_ for (const vectorEntity of vectorEntitiesSaathratri) { _%>
        totalMigrated += migrate<%= vectorEntity.entityClass %>EmbeddingsIfNeeded();
<%_ } _%>

        if (totalMigrated > 0) {
            LOG.info("Embedding startup migration completed. Total records updated: {}", totalMigrated);
        } else {
            LOG.info("Embedding startup migration: No records needed embedding updates.");
        }
    }

<%_ for (const vectorEntity of vectorEntitiesSaathratri) { _%>
    /**
     * Migrate embeddings for <%= vectorEntity.entityClass %> entities that have NULL embeddings.
     *
     * @return number of records updated
     */
    private int migrate<%= vectorEntity.entityClass %>EmbeddingsIfNeeded() {
        AtomicInteger updated = new AtomicInteger(0);

        // Find all entities - we'll filter in memory for those needing embeddings
        List<<%= vectorEntity.entityClass %>> entities = <%= vectorEntity.entityInstance %>Repository.findAll();

        for (<%= vectorEntity.entityClass %> entity : entities) {
            boolean wasUpdated = false;
<%_ for (const field of vectorEntity.vectorFields) { _%>

            // Generate embedding for <%= field.sourceFieldName %> -> <%= field.fieldName %>
            if (entity.get<%= field.fieldNameCapitalized %>() == null && entity.get<%= field.sourceFieldNameCapitalized %>() != null) {
                String sourceText = entity.get<%= field.sourceFieldNameCapitalized %>()<% if (field.sourceFieldName !== 'name' && field.sourceFieldName !== 'title' && field.sourceFieldName !== 'description' && field.sourceFieldName !== 'note' && field.sourceFieldName !== 'notes' && field.sourceFieldName !== 'termsAndConditions') { %>.toString()<% } %>;
                if (sourceText != null && !sourceText.isBlank()) {
                    // Use vector string format for pgvector compatibility: "[0.1, 0.2, ...]"
                    float[] embedding = embeddingService.generateEmbedding(sourceText);
                    if (embedding != null) {
                        entity.set<%= field.fieldNameCapitalized %>(embedding);
                        wasUpdated = true;
                        LOG.debug("Generated <%= field.fieldName %> for <%= vectorEntity.entityClass %> id={}", entity.getId());
                    }
                    rateLimitDelay();
                }
            }
<%_ } _%>

            if (wasUpdated) {
                <%= vectorEntity.entityInstance %>Repository.save(entity);
                updated.incrementAndGet();
            }
        }

        if (updated.get() > 0) {
            LOG.info("<%= vectorEntity.entityClass %>: {} records updated with embeddings", updated.get());
        }

        return updated.get();
    }

<%_ } _%>
    private void rateLimitDelay() {
        try {
            Thread.sleep(RATE_LIMIT_DELAY_MS);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
    }
}
